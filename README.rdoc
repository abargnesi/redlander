= Redlander

Redlander is Ruby bindings to Redland library (see http://librdf.org) written in C, which is used to manipulate RDF graphs. This is an alternative implementation of Ruby bindings (as opposed to the official bindings), aiming to be more intuitive, lightweight, high-performing and as bug-free as possible.

= Installing

Installing Redlander is simple:

  $ gem install redlander

Note, that you will have to install Redland runtime library (librdf) for Redlander to work.

= Usage

This README outlines most obvious use cases. For more details please refer to YARD documentation of Redlander.

To start doing anything useful with Redlander, you need to initialize a model first:

  $ m = Redlander::Model.new

This creates a model where all RDF statements are stored in the memory. Depending on the selected storage you may need to supply extra parameters like :user or :password. Look-up the options for Model.initialize for the list of available options.
Naturally, you don't need to create a model if you just want to play around with independent statements, nodes and the like.

== RDF Statements

Now that you have created a model, you can access its RDF statements:

  $ m.statements

Most of Redlander functionality is accessable via these statements. The API is almost identical to ActiveRecord:

  $ s = URI.parse('http://example.com/concepts#subject')
  $ p = URI.parse('http://example.com/concepts#label')
  $ o = "subject!"
  $ m.statements.create(:subject => s, :predicate => p, :object => o)

  $ m.statements.empty?  # => false

  $ st = Redlander::Statement.new(:subject => s, :predicate => p, :object => "another label")
  $ m.statements.add(st)

  $ m.statements.size    # => 2

  $ m.statements.each { |st| puts st }

Finding statements:

  m.statements.find(:first, :object => "subject!")
  m.statements.all(:object => "another label")
  m.statements.each(:object => "subject!") { |statement|
    puts statement.subject
  }

Note that "m.statements.each" is "lazy", while "m.statements.all" (and other finders) is not.

== Parsing Input

You can fill your model with statements by parsing some external sources like plain or streamed data.

  $ data = File.read("data.xml")
  $ m.from(data, :format => "rdfxml")

If the input is too large, you may prefer streaming it:

  $ source = URI("http://example.com/data.nt")
  $ m.from(source, :format => "ntriples")

If you want to get the data from a local file, you can use "file://" schema for your URI
(or Redlander::Uri) or use "from_file" method with a local file name (without schema):

  $ m.from_file("../data.ttl", :format => "turtle")

Most frequently used parsing methods are aliased to save you some typing:
"from_rdfxml", "from_ntriples", "from_turtle", "from_uri/from_file".

== Serializing Model

Naturally, you can convert your model into a portable syntax:

  $ m.to(:format => "rdfxml") # => RDF/XML output

There are aliases as well: "to_rdfxml", "to_dot", etc.

You can also dump the output directly into a local file:

  $ m.to_file("data.nt", :format => "ntriples")

== Transactions

It is possible to wrap all changes you perform on a model in a transaction,
if transactions are supported by the backend storage. If they are not supported,
all changes will be instantaneous.

  $ m.transaction { m.statements.delete_all }

There are also dedicated methods to start, commit and rollback a transaction,
should you not be able to explicitly wrap your changes in a block:

  $ m.transaction_start
  $ m.delete_all
  $ if lucky?
      m.transaction_commit
    else
      m.transaction_rollback
    end

All the above methods have their "banged" counterparts ("transaction_start!",
"transaction_commit!" and "transaction_rollback!") that would raise RedlandError
in case of an error.


= Exceptions

If anything unexpected happens, Redlander raises RedlandError.

= Authors and Contributors

Slava Kravchenko <slava.kravchenko@gmail.com>

= Thanks

Thanks goes to Dave Beckett, the creator of Redland!
